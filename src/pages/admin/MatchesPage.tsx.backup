import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import DashboardLayout from '../../components/layout/DashboardLayout';
import PageHeader from '../../components/layout/PageHeader';
import Card from '../../components/common/Card';
import Button from '../../components/common/Button';
import Table, { type TableColumn } from '../../components/common/Table';
import Badge from '../../components/common/Badge';
import Select from '../../components/common/Select';
import Input from '../../components/common/Input';
import SearchBar from '../../components/common/SearchBar';
import Avatar from '../../components/common/Avatar';
import ConfirmDialog from '../../components/common/ConfirmDialog';
import MatchModal from '../../components/admin/MatchModal';
import VideoPreviewModal from '../../components/admin/VideoPreviewModal';
import type { MatchListItem, Match, MatchStatus, PaginatedResponse } from '../../types/match';
import { STATUS_OPTIONS } from '../../types/match';
import { getAllMatches, getMatchById, deleteMatch } from '../../services/matchService';
import { getAllTeams } from '../../services/teamService';
import type { TeamListItem } from '../../types/team';
import { showSuccess, showError, showInfo } from '../../utils/toast';

/**
 * MatchesPage
 * 
 * Matches management page with team and status filters.
 * Displays matches in a table with pagination, loading, and empty states.
 * 
 * OPTIONAL ENHANCEMENTS IMPLEMENTED:
 * âœ… CSV Export - Export filtered matches to CSV file
 * âœ… Copy Match Link - Copy shareable link to clipboard
 * âœ… Stats Button - Navigate to match statistics (completed matches only)
 * âœ… View Mode Toggle - Infrastructure for table/calendar/card views (calendar/card TODO)
 * âœ… Responsive Enhancements - Horizontal scroll, better mobile layout
 * 
 * OPTIONAL ENHANCEMENTS TODO:
 * â³ Calendar View - Month calendar grid showing matches on dates
 * â³ Card View - Visual card layout with team logos and video thumbnails
 * â³ Video Thumbnails - Show YouTube/Vimeo thumbnails instead of camera icon
 * â³ Quick Stats on Hover - Tooltip showing team form, head-to-head, venue info
 */
const MatchesPage: React.FC = () => {
	const navigate = useNavigate();

	// Data state
	const [matches, setMatches] = useState<MatchListItem[]>([]);
	const [count, setCount] = useState<number>(0);
	const [teams, setTeams] = useState<TeamListItem[]>([]);

	// OPTIONAL: View mode state (table | calendar | card)
	// TODO: Implement calendar and card views
	const [viewMode, setViewMode] = useState<'table' | 'calendar' | 'card'>('table');

	// UI state
	const [loading, setLoading] = useState<boolean>(false);
	const [loadingTeams, setLoadingTeams] = useState<boolean>(false);
	const [loadingMatch, setLoadingMatch] = useState<boolean>(false);
	const [error, setError] = useState<string>('');

	// Controls
	const [page, setPage] = useState<number>(1);

	// Modal state
	const [showCreateModal, setShowCreateModal] = useState<boolean>(false);
	const [showEditModal, setShowEditModal] = useState<boolean>(false);
	const [selectedMatch, setSelectedMatch] = useState<Match | null>(null);

	// Delete dialog state
	const [deleteDialogOpen, setDeleteDialogOpen] = useState<boolean>(false);
	const [matchToDelete, setMatchToDelete] = useState<MatchListItem | null>(null);
	const [deleting, setDeleting] = useState<boolean>(false);

	// Video preview state
	const [showVideoPreview, setShowVideoPreview] = useState<boolean>(false);
	const [selectedMatchForVideo, setSelectedMatchForVideo] = useState<Match | null>(null);
	const [loadingVideoMatch, setLoadingVideoMatch] = useState<boolean>(false);
	
	// Filters
	const [teamFilter, setTeamFilter] = useState<string>('');
	const [statusFilter, setStatusFilter] = useState<MatchStatus | ''>('');
	const [dateFrom, setDateFrom] = useState<string>('');
	const [dateTo, setDateTo] = useState<string>('');
	const [competitionFilter, setCompetitionFilter] = useState<string>('');
	const [debouncedCompetition, setDebouncedCompetition] = useState<string>('');
	
	// Date validation error
	const [dateError, setDateError] = useState<string>('');

	// Refs for cleanup
	const abortControllerRef = useRef<AbortController | null>(null);

	// Derived
	const pageSize = 10; // aligned with backend PAGE_SIZE
	const totalPages = useMemo(() => Math.max(1, Math.ceil(count / pageSize)), [count]);

	// Helper: Format date nicely (e.g., "Dec 5, 2024")
	const formatDate = (iso: string) => {
		try {
			const d = new Date(iso);
			return d.toLocaleDateString(undefined, {
				month: 'short', day: 'numeric', year: 'numeric',
			});
		} catch {
			return iso;
		}
	};

	// Helper: Status badge variant
	const statusVariant = (status: string): 'info' | 'success' | 'danger' => {
		switch (status) {
			case 'Scheduled':
				return 'info';
			case 'Completed':
				return 'success';
			case 'Cancelled':
				return 'danger';
			default:
				return 'info';
		}
	};

	// Fetch teams for filter dropdown
	const fetchTeams = useCallback(async () => {
		setLoadingTeams(true);
		try {
			const res = await getAllTeams({});
			const teamList = Array.isArray(res?.results) ? res.results : [];
			setTeams(teamList);
		} catch (err: any) {
			console.error('Failed to fetch teams:', err);
			setTeams([]);
		} finally {
			setLoadingTeams(false);
		}
	}, []);

	// Fetch matches
	const fetchMatches = useCallback(async () => {
		// Cancel previous request if still pending
		if (abortControllerRef.current) {
			abortControllerRef.current.abort();
		}

		const controller = new AbortController();
		abortControllerRef.current = controller;

		setLoading(true);
		setError('');

		try {
			// Build query params
			const params: any = { page };
			if (teamFilter) params.team = Number(teamFilter);
			if (statusFilter) params.status = statusFilter;
			if (dateFrom) params.date_from = dateFrom;
			if (dateTo) params.date_to = dateTo;
			if (debouncedCompetition) params.competition = debouncedCompetition;

			const res: PaginatedResponse<MatchListItem> = await getAllMatches(params);
			if (controller.signal.aborted) return;
			
			// Safely extract results and count
			const list = Array.isArray(res?.results) ? res.results : [];
			const total = typeof res?.count === 'number' ? res.count : 0;
			
			setMatches(list);
			setCount(total);
		} catch (err: any) {
			if (controller.signal.aborted) return;
			setError(err?.message || 'Failed to load matches.');
			setMatches([]);
			setCount(0);
			console.error('Failed to fetch matches:', err);
		} finally {
			if (!controller.signal.aborted) setLoading(false);
		}
	}, [page, teamFilter, statusFilter, dateFrom, dateTo, debouncedCompetition]);

	// Fetch teams on mount
	useEffect(() => {
		fetchTeams();
	}, [fetchTeams]);

	// Debounce competition search (300ms delay)
	useEffect(() => {
		const timer = setTimeout(() => {
			setDebouncedCompetition(competitionFilter.trim());
		}, 300);
		return () => clearTimeout(timer);
	}, [competitionFilter]);

	// Fetch matches when page or filters change
	useEffect(() => {
		fetchMatches();
		return () => {
			if (abortControllerRef.current) abortControllerRef.current.abort();
		};
	}, [fetchMatches]);

	// Filter handlers
	const handleTeamFilterChange = (value: string | number | (string | number)[]) => {
		setTeamFilter(String(value));
		setPage(1); // Reset to first page when filter changes
	};

	const handleStatusFilterChange = (value: string | number | (string | number)[]) => {
		setStatusFilter(value as MatchStatus | '');
		setPage(1); // Reset to first page when filter changes
	};

	const handleDateFromChange = (e: React.ChangeEvent<HTMLInputElement>) => {
		const value = e.target.value;
		setDateFrom(value);
		setPage(1);
		
		// Validate: dateTo must be >= dateFrom
		if (dateTo && value && dateTo < value) {
			setDateError('To date must be on or after from date');
		} else {
			setDateError('');
		}
	};

	const handleDateToChange = (e: React.ChangeEvent<HTMLInputElement>) => {
		const value = e.target.value;
		setDateTo(value);
		setPage(1);
		
		// Validate: dateTo must be >= dateFrom
		if (dateFrom && value && value < dateFrom) {
			setDateError('To date must be on or after from date');
		} else {
			setDateError('');
		}
	};

	const handleClearDateFrom = () => {
		setDateFrom('');
		setDateError('');
		setPage(1);
	};

	const handleClearDateTo = () => {
		setDateTo('');
		setDateError('');
		setPage(1);
	};

	const handleCompetitionChange = (value: string) => {
		setCompetitionFilter(value);
		// Don't reset page here - debounce will handle the fetch
	};

	const handleClearFilters = () => {
		setTeamFilter('');
		setStatusFilter('');
		setDateFrom('');
		setDateTo('');
		setCompetitionFilter('');
		setDateError('');
		setPage(1);
	};

	// Check if any filters are active
	const activeFilterCount = useMemo(() => {
		let count = 0;
		if (teamFilter) count++;
		if (statusFilter) count++;
		if (dateFrom) count++;
		if (dateTo) count++;
		if (debouncedCompetition) count++;
		return count;
	}, [teamFilter, statusFilter, dateFrom, dateTo, debouncedCompetition]);

	const hasActiveFilters = activeFilterCount > 0;

	// Modal handlers
	const openCreateModal = () => {
		setSelectedMatch(null);
		setShowCreateModal(true);
	};

	const handleEdit = async (match: MatchListItem) => {
		setLoadingMatch(true);
		try {
			const fullMatch = await getMatchById(match.id);
			setSelectedMatch(fullMatch);
			setShowEditModal(true);
		} catch (err: any) {
			console.error('Failed to fetch match details:', err);
			showError(err.message || 'Failed to load match details.');
		} finally {
			setLoadingMatch(false);
		}
	};

	const handleDelete = (match: MatchListItem) => {
		setMatchToDelete(match);
		setDeleteDialogOpen(true);
	};

	const confirmDelete = async () => {
		if (!matchToDelete) return;

		setDeleting(true);
		try {
			await deleteMatch(matchToDelete.id);
			showSuccess('Match deleted successfully!');
			setDeleteDialogOpen(false);
			setMatchToDelete(null);
			// Refresh matches list
			fetchMatches();
		} catch (err: any) {
			console.error('Failed to delete match:', err);
			showError(err.message || 'Failed to delete match.');
		} finally {
			setDeleting(false);
		}
	};

	const handleVideoClick = async (match: MatchListItem) => {
		if (!match.has_video) return;

		setLoadingVideoMatch(true);
		try {
			const fullMatch = await getMatchById(match.id);
			if (fullMatch.video_url && fullMatch.video_url.trim() !== '') {
				setSelectedMatchForVideo(fullMatch);
				setShowVideoPreview(true);
			} else {
				showError('Video URL not available for this match.');
			}
		} catch (err: any) {
			console.error('Failed to fetch match video:', err);
			showError(err.message || 'Failed to load match video.');
		} finally {
			setLoadingVideoMatch(false);
		}
	};

	const handleModalSuccess = () => {
		// Refresh matches list
		fetchMatches();
	};

	const handleModalClose = () => {
		setShowCreateModal(false);
		setShowEditModal(false);
		setSelectedMatch(null);
	};

	const handlePageChange = (newPage: number) => {
		setPage(newPage);
		window.scrollTo({ top: 0, behavior: 'smooth' });
	};

	// ============================================================================
	// OPTIONAL ENHANCEMENTS
	// ============================================================================

	/**
	 * OPTIONAL: Export matches to CSV
	 * Exports current filtered matches to a CSV file
	 */
	const handleExportCSV = useCallback(() => {
		try {
			// CSV headers
			const headers = ['Date', 'Home Team', 'Away Team', 'Score', 'Competition', 'Status'];
			const rows = matches.map((match) => [
				formatDate(match.match_date),
				match.home_team_name,
				match.away_team_name,
				match.score_display || 'â€”',
				match.competition,
				match.status,
			]);

			// Combine headers and rows
			const csvContent = [
				headers.join(','),
				...rows.map((row) => row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(',')),
			].join('\n');

			// Create blob and download
			const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
			const link = document.createElement('a');
			const url = URL.createObjectURL(blob);
			link.setAttribute('href', url);
			link.setAttribute('download', `matches_${new Date().toISOString().split('T')[0]}.csv`);
			link.style.visibility = 'hidden';
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);

			showSuccess('Matches exported to CSV successfully!');
		} catch (err: any) {
			console.error('Failed to export CSV:', err);
			showError('Failed to export matches to CSV.');
		}
	}, [matches]);

	/**
	 * OPTIONAL: Copy match link to clipboard
	 * Copies a shareable link to the match
	 */
	const handleCopyMatchLink = useCallback(async (matchId: number) => {
		try {
			const link = `${window.location.origin}/admin/matches/${matchId}`;
			await navigator.clipboard.writeText(link);
			showInfo('Link copied to clipboard!');
		} catch (err: any) {
			console.error('Failed to copy link:', err);
			showError('Failed to copy link to clipboard.');
		}
	}, []);

	/**
	 * OPTIONAL: Navigate to match stats page
	 * Only available for completed matches
	 */
	const handleViewStats = useCallback((matchId: number) => {
		navigate(`/admin/stats/match/${matchId}`);
	}, [navigate]);

	/**
	 * OPTIONAL: Toggle view mode (table/calendar/card)
	 * TODO: Implement calendar and card views
	 */
	const handleViewModeChange = useCallback((mode: 'table' | 'calendar' | 'card') => {
		setViewMode(mode);
		// Persist to localStorage
		localStorage.setItem('matchesViewMode', mode);
	}, []);

	// Load view mode preference from localStorage
	useEffect(() => {
		const savedViewMode = localStorage.getItem('matchesViewMode') as 'table' | 'calendar' | 'card' | null;
		if (savedViewMode && ['table', 'calendar', 'card'].includes(savedViewMode)) {
			setViewMode(savedViewMode);
		}
	}, []);

	// Team filter options
	const teamOptions = useMemo(() => {
		return [
			{ value: '', label: 'All Teams' },
			...teams.map(team => ({ value: String(team.id), label: team.name }))
		];
	}, [teams]);

	// Status filter options
	const statusOptions = useMemo(() => {
		return [
			{ value: '', label: 'All Status' },
			...STATUS_OPTIONS.map(opt => ({ value: opt.value, label: opt.label }))
		];
	}, []);

	// Helper: Get team by name (for logo lookup)
	const getTeamByName = useCallback((teamName: string): TeamListItem | null => {
		return teams.find((t) => t.name === teamName) || null;
	}, [teams]);

	// Columns definition
	const columns: TableColumn<MatchListItem>[] = useMemo(() => [
		{
			key: 'match_date',
			label: 'Date',
			sortable: true,
			render: (m) => <span className="text-gray-900 font-medium">{formatDate(m.match_date)}</span>,
		},
		{
			key: 'teams',
			label: 'Match',
			render: (m) => {
				const homeTeam = getTeamByName(m.home_team_name);
				const awayTeam = getTeamByName(m.away_team_name);
				return (
					<div className="flex items-center gap-2">
						{/* Home Team */}
						<div className="flex items-center gap-1.5">
							<Avatar
								src={homeTeam?.logo || undefined}
								alt={m.home_team_name}
								size="sm"
								fallback={m.home_team_name.charAt(0).toUpperCase()}
							/>
							<span className="text-gray-800 font-medium">{m.home_team_name}</span>
						</div>
						<span className="text-gray-400 mx-1">vs</span>
						{/* Away Team */}
						<div className="flex items-center gap-1.5">
							<Avatar
								src={awayTeam?.logo || undefined}
								alt={m.away_team_name}
								size="sm"
								fallback={m.away_team_name.charAt(0).toUpperCase()}
							/>
							<span className="text-gray-800 font-medium">{m.away_team_name}</span>
						</div>
					</div>
				);
			},
		},
		{
			key: 'score_display',
			label: 'Score',
			align: 'center',
			render: (m) => (
				<span className={m.status === 'Completed' ? 'text-gray-900 font-semibold' : 'text-gray-400'}>
					{m.status === 'Completed' ? m.score_display : 'â€”'}
				</span>
			),
			width: '100px',
		},
		{
			key: 'competition',
			label: 'Competition',
			render: (m) => <span className="text-gray-700">{m.competition}</span>,
		},
		{
			key: 'status',
			label: 'Status',
			align: 'center',
			render: (m) => <Badge variant={statusVariant(m.status)}>{m.status}</Badge>,
			width: '140px',
		},
		{
			key: 'video',
			label: 'Video',
			align: 'center',
			render: (m) => (
				<button
					className={`text-xl transition-opacity ${
						m.has_video
							? 'opacity-100 hover:opacity-80 cursor-pointer'
							: 'opacity-20 cursor-default'
					}`}
					onClick={(e) => {
						e.stopPropagation();
						handleVideoClick(m);
					}}
					aria-label={m.has_video ? 'Watch video' : 'No video available'}
					title={m.has_video ? 'Watch video' : 'No video available'}
					disabled={!m.has_video || loadingVideoMatch}
				>
					{/* OPTIONAL: Replace with video thumbnail */}
					{/* TODO: For YouTube: https://img.youtube.com/vi/{ID}/default.jpg */}
					{/* TODO: For Vimeo: Fetch from API or use fallback icon */}
					ðŸŽ¥
				</button>
			),
			width: '90px',
		},
		{
			key: 'actions',
			label: 'Actions',
			align: 'right',
			render: (m) => (
				<div className="flex gap-1.5 justify-end items-center flex-nowrap">
					{/* OPTIONAL: Stats button (only for completed matches) */}
					{m.status === 'Completed' && (
						<Button
							size="sm"
							variant="secondary"
							onClick={(e) => {
								e.stopPropagation();
								handleViewStats(m.id);
							}}
							title="View match statistics"
							className="whitespace-nowrap"
						>
							Stats
						</Button>
					)}
					<Button
						size="sm"
						variant="secondary"
						onClick={(e) => {
							e.stopPropagation();
							handleEdit(m);
						}}
						disabled={loadingMatch}
						className="whitespace-nowrap"
					>
						Edit
					</Button>
					{/* OPTIONAL: Copy link button - icon only to save space */}
					<Button
						size="sm"
						variant="secondary"
						onClick={(e) => {
							e.stopPropagation();
							handleCopyMatchLink(m.id);
						}}
						title="Copy match link"
						className="p-2 min-w-[32px]"
					>
						<svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path
								strokeLinecap="round"
								strokeLinejoin="round"
								strokeWidth={2}
								d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"
							/>
						</svg>
					</Button>
					<Button
						size="sm"
						variant="danger"
						onClick={(e) => {
							e.stopPropagation();
							handleDelete(m);
						}}
						className="whitespace-nowrap"
					>
						Delete
					</Button>
				</div>
			),
			width: '240px',
		},
	], [getTeamByName, loadingMatch, loadingVideoMatch, handleViewStats, handleCopyMatchLink]);

	return (
		<DashboardLayout>
			<PageHeader
				title="Matches"
				subtitle="Manage fixtures, scores and match videos"
				action={{
					label: 'Add Match',
					onClick: openCreateModal,
					variant: 'primary',
				}}
			/>

			{/* OPTIONAL: Export to CSV button - placed below header */}
			<div className="flex justify-end mb-4">
				<Button variant="secondary" onClick={handleExportCSV} disabled={matches.length === 0}>
					<svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path
							strokeLinecap="round"
							strokeLinejoin="round"
							strokeWidth={2}
							d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
						/>
					</svg>
					Export CSV
				</Button>
			</div>

			{/* OPTIONAL: View Mode Toggle */}
			{/* TODO: Implement calendar and card views */}
			{false && (
				<Card className="mt-6">
					<div className="flex items-center gap-2">
						<span className="text-sm font-medium text-gray-700">View:</span>
						<div className="flex gap-1">
							<Button
								size="sm"
								variant={viewMode === 'table' ? 'primary' : 'secondary'}
								onClick={() => handleViewModeChange('table')}
							>
								Table
							</Button>
							<Button
								size="sm"
								variant={viewMode === 'calendar' ? 'primary' : 'secondary'}
								onClick={() => handleViewModeChange('calendar')}
								disabled
							>
								Calendar
							</Button>
							<Button
								size="sm"
								variant={viewMode === 'card' ? 'primary' : 'secondary'}
								onClick={() => handleViewModeChange('card')}
								disabled
							>
								Card
							</Button>
						</div>
					</div>
				</Card>
			)}

			{/* Filters Section */}
			<Card className="mt-6">
				<div className="flex flex-wrap items-end gap-4">
					{/* Team Filter */}
					<div className="flex-1 min-w-[200px]">
						<Select
							label="Filter by Team"
							options={teamOptions}
							value={teamFilter}
							onChange={handleTeamFilterChange}
							placeholder="All Teams"
							disabled={loadingTeams}
						/>
					</div>

					{/* Status Filter */}
					<div className="flex-1 min-w-[200px]">
						<Select
							label="Status"
							options={statusOptions}
							value={statusFilter}
							onChange={handleStatusFilterChange}
							placeholder="All Status"
						/>
					</div>

					{/* Date From Input */}
					<div className="flex-1 min-w-[180px]">
						<Input
							type="date"
							label="From Date"
							value={dateFrom}
							onChange={handleDateFromChange}
							rightElement={
								dateFrom ? (
									<button
										type="button"
										onClick={handleClearDateFrom}
										className="text-gray-400 hover:text-gray-600 transition-colors"
										aria-label="Clear from date"
									>
										<svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
											<path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
										</svg>
									</button>
								) : undefined
							}
						/>
					</div>

					{/* Date To Input */}
					<div className="flex-1 min-w-[180px]">
						<Input
							type="date"
							label="To Date"
							value={dateTo}
							onChange={handleDateToChange}
							error={dateError}
							rightElement={
								dateTo ? (
									<button
										type="button"
										onClick={handleClearDateTo}
										className="text-gray-400 hover:text-gray-600 transition-colors"
										aria-label="Clear to date"
									>
										<svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
											<path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
										</svg>
									</button>
								) : undefined
							}
						/>
					</div>

					{/* Competition Search */}
					<div className="flex-1 min-w-[200px]">
						<label className="block text-sm font-medium text-gray-700 mb-1.5">
							Competition
						</label>
						<SearchBar
							placeholder="Search competition..."
							value={competitionFilter}
							onChange={handleCompetitionChange}
						/>
					</div>

					{/* Clear Filters Button with Badge */}
					{hasActiveFilters && (
						<div className="flex-shrink-0 flex items-center gap-2">
							{activeFilterCount > 0 && (
								<Badge variant="info" className="text-xs">
									{activeFilterCount}
								</Badge>
							)}
							<Button
								variant="secondary"
								onClick={handleClearFilters}
								className="whitespace-nowrap"
							>
								Clear Filters
							</Button>
						</div>
					)}
				</div>

				{/* Active Filter Indicator */}
				<div className="mt-4 text-sm text-gray-600">
					{loading ? (
						<span>Loading matches...</span>
					) : (
						<span>
							Showing <strong>{count}</strong> {count === 1 ? 'match' : 'matches'}
							{hasActiveFilters && ' (filtered)'}
						</span>
					)}
				</div>
			</Card>

			{/* Matches Table */}
			{/* OPTIONAL: Add sticky header and horizontal scroll for mobile */}
			<Card className="mt-6 overflow-x-auto">
				<div className="min-w-full">
					<Table
						columns={columns}
						data={matches}
						loading={loading}
						emptyState={{
							title: hasActiveFilters ? 'No matches found' : 'No matches yet',
							message: hasActiveFilters
								? 'Try adjusting your filters to see more results.'
								: 'Create your first match to get started!',
							action: hasActiveFilters
								? { label: 'Clear Filters', onClick: handleClearFilters }
								: { label: 'Add Match', onClick: openCreateModal },
						}}
						pagination={
							count > 0
								? {
										currentPage: page,
										totalPages: totalPages,
										onPageChange: handlePageChange,
									}
								: undefined
						}
					/>
				</div>
			</Card>

			{/* OPTIONAL: Calendar View */}
			{/* TODO: Implement calendar view using react-calendar or custom component */}
			{viewMode === 'calendar' && false && (
				<Card className="mt-6">
					<div className="p-4 text-center text-gray-500">
						Calendar view coming soon...
					</div>
				</Card>
			)}

			{/* OPTIONAL: Card View */}
			{/* TODO: Implement card view with team logos, scores, and video thumbnails */}
			{viewMode === 'card' && false && (
				<Card className="mt-6">
					<div className="p-4 text-center text-gray-500">
						Card view coming soon...
					</div>
				</Card>
			)}

			{/* Match Modal (Create/Edit) */}
			<MatchModal
				isOpen={showCreateModal || showEditModal}
				onClose={handleModalClose}
				match={selectedMatch}
				onSuccess={handleModalSuccess}
			/>

			{/* Delete Confirmation Dialog */}
			<ConfirmDialog
				isOpen={deleteDialogOpen}
				title="Delete Match"
				message={
					matchToDelete
						? `Are you sure you want to delete ${matchToDelete.home_team_name} vs ${matchToDelete.away_team_name}? This cannot be undone.`
						: 'Are you sure you want to delete this match?'
				}
				onConfirm={confirmDelete}
				onCancel={() => {
					setDeleteDialogOpen(false);
					setMatchToDelete(null);
				}}
				danger={true}
				confirmLabel="Delete"
				loading={deleting}
			/>

			{/* Video Preview Modal */}
			{selectedMatchForVideo && selectedMatchForVideo.video_url && (
				<VideoPreviewModal
					isOpen={showVideoPreview}
					onClose={() => {
						setShowVideoPreview(false);
						setSelectedMatchForVideo(null);
					}}
					platform={selectedMatchForVideo.video_platform}
					videoUrl={selectedMatchForVideo.video_url}
					matchInfo={{
						homeTeam: selectedMatchForVideo.home_team.name,
						awayTeam: selectedMatchForVideo.away_team.name,
						matchDate: selectedMatchForVideo.match_date,
					}}
				/>
			)}
		</DashboardLayout>
	);
};

export default MatchesPage;

